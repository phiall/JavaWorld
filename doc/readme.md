## 0.什么才叫精通了一门编程语言

一直以来我都有一个幻想，我想精通所有的主流语言，后来发现哪怕精通一门语言也不是那么容易。

我一直在反思，那什么叫精通呢？

知其然不知所以然，不叫精通

总是坚守在自己专门的一亩三分地，不做全局审视，不叫精通

我个人认为所谓精通应该有几点：

（1）能灵活运用语言提供的特性实现自己需要的功能，并且能够熟练使用某类语言生态中现有的工具，高效有效地从事领域内的开发工作。

（2）能够理解语言的设计思想，对于语言本身如何将用户编写的程序代码最终转化为可执行的机器代码整个过程有一系统的把握

（3）当应用在使用过程中出现问题时，能够迅速有效的运用相关的工具解决问题

本人从事Java开发前前后后也有2年左右了，但一直没有信心说出我是精通Java的，原因很简单我大多时间是停留在解决工程应用层面，没有彻底地静下心去深入钻研一下Java的关键技术，甚至底层的设计思想及实现。接下来，我希望可以从全局到局部系统的梳理一遍Java核心编程技术，语言是相通的，编程语言的设计思想许多都是类似的。

另外，既然说到编程语言，这里索性就对编程语言的分类做一点总结吧，省得以后突然想到此处，不明所以。

从语言与硬件的距离来看：编程语言可以分为机器语言、汇编语言、高级语言（C/Java/Python等）

从是否需要编译来看：编程语言可以分为编译型语言（C/Java等）、解释型语言（Python/JavaScript等）、混合型语言（C#等）

从运行过程中结构是否可变来看：编程语言分为动态语言（JavaScript/Python/Object-C等）、静态语言（C/C++/Java等）

## 1.怎么理解Java平台

从Java语言的特性来说，一句话就是“一次编译、到处运行”，但它的跨平台特性与JVM的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装 好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以 才有了Java一次编译，到处运行这样的效果。 严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。“一次编译，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。Java虚拟机和DOS类似，相当于一个 供程序运行的平台。 程序从源代码到运行的三个阶段：编码——编译——运行——调试。Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的：首先是将Java源代码转化成.CLASS文件字节码，这是第 一次编译。.class文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。 “到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实 现了“到处运行”的效果。需要强调的一点是，java并不是编译机制，而是解释机制。Java字节码的设计充分考虑了JIT这一即时编译方式，可以将字节码直接转化成高性能的本地机器码，这同样 是虚拟机的一个构成部分

宏观角度： 跟c/c++最大的不同点在于，c/c++编程是面向操作系统的，需要开发者极大地关心不同操作系统之间的差异性；而Java平台通过虚拟机屏蔽了操作系统的底层细节，使得开发者无需过多地关 心不同操作系统之间的差异性。 通过增加一个间接的中间层来进行”解耦“是计算机领域非常常用的一种”艺术手法“，虚拟机是这样，操作系统是这样，HTTP也是这样。

Java平台已经形成了一个生态系统，在这个生态系统中，有着诸多的研究领域和应用领域： 1. 虚拟机、编译技术的研究(例如：GC优化、JIT、AOT等)：对效率的追求是人类的另一个天性之一 2. Java语言本身的优化 3. 大数据处理 4. Java并发编程 5. 客户端开发（例如：Android平台） 6. ......
微观角度： Java平台中有两大核心： 1. Java语言本身、JDK中所提供的核心类库和相关工具 2. Java虚拟机以及其他包含的GC 1. Java语言本身、JDK中所提供的核心类库和相关工具 从事Java平台的开发，掌握Java语言、核心类库以及相关工具是必须的，我觉得这是基础中的基础。 >> 对语言本身的了解，需要开发者非常熟悉语言的语法结构；而Java又是一种面对对象的语言，这又需要开发者深入了解面对对象的设计理念； >> Java核心类库包含集合类、线程相关类、IO、NIO、J.U.C并发包等； >> JDK提供的工具包含：基本的编译工具、虚拟机性能检测相关工具等。 2. Java虚拟机 Java语言具有跨平台的特性，也正是因为虚拟机的存在。Java源文件被编译成字节码，被虚拟机加载后执行。这里隐含的意思有两层： 1）大部分情况下，编程者只需要关心Java语言本身，而无需特意关心底层细节。包括对内存的分配和回收，也全权交给了GC。 2）对于虚拟机而言，只要是符合规范的字节码，它们都能被加载执行，当然，能正常运行的程序光满足这点是不行的，程序本身需要保证在运行时不出现异常。所 以，Scala、Kotlin、Jython等语言也可以跑在虚拟机上。 围绕虚拟机的效率问题展开，将涉及到一些优化技术，例如：JIT、AOT。因为如果虚拟机加载字节码后，完全进行解释执行，这势必会影响执行效率。所以，对于这个运行环节，虚拟机会进行 一些优化处理，例如JIT技术，会将某些运行特别频繁的代码编译成机器码。而AOT技术，是在运行前，通过工具直接将字节码转换为机器码。

## 2.Exception和Error的区别

![常见Exception与Error](https://blog.heping.tech/Images/JavaCore/Throwable.png)

异常类分两大类型：
Error类代表了编译和系统的错误，不允许捕获；
Exception类代表了标准Java库方法所激发的异常。Exception类还包含运行异常类RuntimeException和多个非运行时的异常类

NoClassDefFoundError和ClassNotFoundException什么区别?

try-catch-fnally块，throw、throws?

除非真的不在意，不要直接使用异常的超类捕获异常
除非真的不在意，不要直接生吞异常
打印异常堆栈，需要使用专门的日志系统，否则在分布式系统中不便排查异常发生位置

Throw early, catch late原则

自定义异常，这个时候除了保证提供足够的信息，还有两点需要考虑：

是否需要定义成Checked Exception，因为这种类型设计的初衷更是为了从异常情况恢复，作为异常设计者，我们往往有充足信息进行分类。 

在保证诊断信息足够的同时，也要考虑避免包含敏感信息，因为那样可能导致潜在的安全问题。如果我们看Java的标准类库，你可能注意到类似java.net.ConnectException， 出错信息是类似“ Connection refused (Connection refused)”，而不包含具体的机器名、IP、端口等，一个重要考量就是信息安全。类似的情况在日志中也有，比如，用户数 据一般是不可以输出到日志里面的

业界有一种争论（甚至可以算是某种程度的共识），Java语言的Checked Exception也许是个设计错误，反对者列举了几点：
Checked Exception的假设是我们捕获了异常，然后恢复程序。但是，其实我们大多数情况下，根本就不可能恢复。Checked Exception的使用，已经大大偏离了最初的设计目 的。
Checked Exception不兼容functional编程，如果你写过Lambda/Stream代码，相信深有体会。

从性能角度来审视一下Java的异常处理机制，这里有两个可能会相对昂贵的地方：
try-catch代码段会产生额外的性能开销，或者换个角度说，它往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，尽量不要一个大的try包住整段的代码；与此同 时，利用异常控制代码流程，也不是一个好主意，远比我们通常意义上的条件语句（if/else、switch）要低效。
Java每实例化一个Exception，都会对当时的栈进行快照，这是一个相对比较重的操作。如果发生的非常频繁，这个开销可就不能被忽略了。
所以，对于部分追求极致性能的底层类库，有种方式是尝试创建不进行栈快照的Exception。这本身也存在争议，因为这样做的假设在于，我创建异常时知道未来是否需要堆栈。问 题是，实际上可能吗？小范围或许可能，但是在大规模项目中，这么做可能不是个理智的选择。如果需要堆栈，但又没有收集这些信息，在复杂情况下，尤其是类似微服务这种分布 式系统，这会大大增加诊断的难度。

3.final finally finalize的区别

4.强引用 软引用 弱引用 幻象引用的区别

5.String StringBuffer StringBuilder区别

6.动态代理实现原理

7.int和Integer区别

8.对比Vector ArrayList LinkedList

9.HashTable HashMap TreeMap

10.如何保证集合线程安全，ConcurrentHashMap如何高效的实现线程安全

11.IO方式有哪些？NIO如何实现多路复用

12.Java有几种文件拷贝方式，哪种最高效

13.接口和抽象类有什么区别

14.设计模式

15.synchronized和ReentrantLock区别

16.synchronized底层如何实现？什么是锁升级、降级

17.一个线程2次调用start()方法会出现什么情况

18.什么情况下Java会出现死锁，怎么定位、修复

19.Java并发包提供了哪些并发工具类

20.并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？ 

21.Java并发类库提供的线程池有哪几种？ 分别有什么特点？

22.AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？

23.请介绍类加载过程，什么是双亲委派模型？ 

24.有哪些方法可以在运行时动态生成一个Java类？ 

25.谈谈JVM内存区域的划分，哪些区域可能发生OutOfMemoryError? 

26.如何监控和诊断JVM堆内和堆外内存使用？ 

27.Java常见的垃圾收集器有哪些？ 

28.谈谈你的GC调优思路? 

29.Java内存模型中的happen-before是什么？ 

30.Java程序运行在Docker等容器环境有哪些新问题？ 

31.你了解Java应用开发中的注入攻击吗？ 

32.如何写出安全的Java代码？ 

33.后台服务出现明显“变慢”，谈谈你的诊断思路？

34.有人说“Lambda能让Java程序慢30倍”，你怎么看？ 

35.JVM优化Java代码时都做了什么

36.MySQL支持的事务隔离级别，悲观锁和乐观锁原理和应用场景

37.Spring Bean的生命周期及作用域

38.对比JavaNIO类库，Netty如何实现更高性能的

39.常用分布式ID设计方案？Snowflake是否受冬令时切换影响

必读书单  